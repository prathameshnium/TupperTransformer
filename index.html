<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TupperTransformer Demo</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Keep canvas pixels sharp and crisp when scaled */
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%;
            aspect-ratio: 106 / 17;
            background-color: #f0f0f0;
        }
        /* Simple syntax highlighting for the BibTeX block */
        pre[class*="language-"] {
            padding: 1em;
            margin: .5em 0;
            overflow: auto;
            border-radius: 0.3em;
            background: #fdf6e3; /* Solarized Light */
            color: #657b83;
        }
        .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #93a1a1; }
        .token.punctuation { color: #657b83; }
        .token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted { color: #cb4b16; }
        .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { color: #2aa198; }
        .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { color: #d33682; }
        .token.atrule, .token.attr-value, .token.keyword { color: #859900; }
        .token.function, .token.class-name { color: #b58900; }
        .token.regex, .token.important, .token.variable { color: #cb4b16; }

        /* Styles for the new "tab" buttons */
        .tab-button {
            @apply w-full font-semibold py-3 px-4 rounded-lg transition-colors shadow-sm text-gray-700 bg-gray-200 hover:bg-gray-300;
        }
        .tab-button[aria-selected="true"] {
            @apply text-white;
        }
        /* Specific active colors for each tab */
        #btnAnimTab[aria-selected="true"] {
            @apply bg-blue-600;
        }
        #btnTetrisTab[aria-selected="true"] {
            @apply bg-orange-500;
        }
        #btnManualTab[aria-selected="true"] {
            @apply bg-indigo-600;
        }
        /* Add user-select-none to prevent text highlighting when rapidly clicking/holding buttons */
        .manual-anim-button {
            @apply select-none;
        }

    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8 flex items-center justify-center font-sans">

    <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 w-full max-w-3xl relative">
        
        <!-- GitHub Link -->
        <a href="https://github.com/prathameshnium/TupperTransformer" target="_blank" rel="noopener noreferrer" title="View on GitHub" class="absolute top-6 right-6 text-gray-400 hover:text-gray-600 transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
            </svg>
        </a>
        
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-2">TupperTransformer</h1>
        <p class="text-center text-gray-600 mb-6">
            An interactive demo of the transformation algorithms from my 2018 paper.
        </p>

        <!-- "Read More" Button -->
        <div class="text-center mb-6">
            <button id="btnReadMore" class="text-blue-600 font-medium hover:underline focus:outline-none">Read more about this project</button>
        </div>

        <div class="bg-gray-200 rounded-lg p-2 overflow-hidden">
            <canvas id="tupperCanvas" width="106" height="17"></canvas>
        </div>

        <!-- K-Value Input -->
        <div class="mt-6">
            <label for="k_value" class="block text-sm font-medium text-gray-700">Current K-Value:</label>
            <textarea id="k_value" rows="6" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 font-mono text-xs"></textarea>
        </div>

        <!-- Tabbed Control Interface -->
        <div class="mt-6">
            <!-- Tab Buttons -->
            <div class="grid grid-cols-3 gap-4" role="tablist">
                <button id="btnAnimTab" role="tab" aria-selected="true" class="tab-button">Animation (Eg3.1)</button>
                <button id="btnTetrisTab" role="tab" aria-selected="false" class="tab-button">Interactive Tetris (Eg3.2)</button>
                <button id="btnManualTab" role="tab" aria-selected="false" class="tab-button">Manual Editor</button>
            </div>

            <!-- Tab Panels -->
            <div class="mt-4">

                <!-- Panel 1: Animation (Eg3.1) -->
                <div id="animationPanel" role="tabpanel">
                    <div class="p-4 border border-blue-200 bg-blue-50 rounded-lg text-center">
                         <h3 class="text-lg font-semibold text-blue-800 mb-4">UFO Animation</h3>
                         <p class="text-blue-700 mb-4 text-sm">Playing animation from Eg3.1. Press Stop to edit.</p>
                         <button id="btnStopAnim" class="w-full md:w-1/2 bg-red-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-600 transition-colors shadow-sm">Stop Animation</button>
                    </div>
                </div>

                <!-- Panel 2: Interactive Tetris (Eg3.2) -->
                <div id="tetrisPanel" role="tabpanel" class="hidden">
                    <div class="p-4 border border-orange-200 bg-orange-50 rounded-lg">
                         <h3 class="text-lg font-semibold text-orange-800 mb-4 text-center">Interactive Tetris Controls (Eg3.2)</h3>
                         <p class="text-orange-700 mb-4 text-sm text-center">Use these buttons to transform the L-piece (ks) independently from the resting pieces (kr).</p>
                         <div class="grid grid-cols-3 gap-3 mt-4 max-w-md mx-auto">
                            <button id="btnTetrisMoveLeft" class="w-full bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Piece Left</button>
                            <button id="btnTetrisMoveDown" class="w-full bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Piece Down</button>
                            <button id="btnTetrisMoveRight" class="w-full bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Piece Right</button>
                         </div>
                    </div>
                </div>
                
                <!-- Panel 3: Manual Editor -->
                <div id="manualPanel" role="tabpanel" class="hidden">
                    <div class="p-4 border border-gray-200 bg-gray-50 rounded-lg">
                        <h3 class="text-lg font-semibold text-gray-800 mb-4 text-center">Load Static Example</h3>
                        <div class="grid grid-cols-2 gap-3">
                            <button id="btnLoadTupper" class="w-full bg-gray-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-700 transition-colors shadow-sm">Load Tupper's</button>
                            <button id="btnLoadUFOCenter" class="w-full bg-gray-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-700 transition-colors shadow-sm">Load UFO (Center)</button>
                        </div>

                        <hr class="my-6 border-gray-300">

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Manual Full Transform -->
                            <div class="bg-white rounded-lg p-4 border border-gray-200">
                                <h3 class="text-md font-semibold text-gray-800 mb-4 text-center">Full Transform (Hold to Animate)</h3>
                                <p class="text-xs text-gray-500 text-center mb-3">Hold for 1 sec to "latch" animation.</p>
                                <div class="grid grid-cols-2 gap-3">
                                    <button id="btnMoveUp" class="manual-anim-button bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Move Up</button>
                                    <button id="btnMoveDown" class="manual-anim-button bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Move Down</button>
                                    <button id="btnMoveLeft" class="manual-anim-button bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Move Left</button>
                                    <button id="btnMoveRight" class="manual-anim-button bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Move Right</button>
                                    <button id="btnMoveDiagUpRight" class="manual-anim-button col-span-2 bg-gray-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-800 transition-colors">Move Diag (Up-Right)</button>
                                    <!-- NEW: Stop button for latched animation -->
                                    <button id="btnStopManualAnim" class="col-span-2 bg-red-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-600 transition-colors hidden">Stop Manual Animation</button>
                                </div>
                            </div>
                            <!-- Pixel Operation -->
                            <div class="bg-white rounded-lg p-4 border border-gray-200">
                                <h3 class="text-md font-semibold text-gray-800 mb-4 text-center">Pixel Operation (Click)</h3>
                                <div>
                                    <label for="pixel_i" class="block text-sm font-medium text-gray-700">Pixel index (i):</label>
                                    <input type="number" id="pixel_i" value="1" min="1" max="1802" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                </div>
                                <div class="grid grid-cols-2 gap-3 mt-3">
                                    <button id="btnAddPixel" class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-600 transition-colors">Add (i)</button>
                                    <button id="btnRemovePixel" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-600 transition-colors">Remove (i)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- "About" Modal -->
    <div id="aboutModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 hidden transition-opacity duration-300 z-50">
        <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 w-full max-w-3xl relative max-h-[90vh] overflow-y-auto">
            <!-- Close Button -->
            <button id="btnCloseModal" class="absolute top-4 right-5 text-gray-400 hover:text-gray-700 text-3xl font-bold focus:outline-none" title="Close">&times;</button>
            
            <h2 class="text-2xl font-bold text-gray-800 mb-4">About TupperTransformer</h2>
            
            <h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">Abstract</h3>
            <p class="text-gray-700 mb-4 italic">
                "My research idea start with a question that if there is some graphical formation at a particular value of k then what can do to change the graphical formation or to change its position. In his research paper, I have shown that:
            </p>
            <ul class="list-disc list-inside space-y-2 mb-4 text-gray-700 italic">
                <li>How to change any graphical formation into other graphical formation by applying some kind of operation to the value of the k</li>
                <li>How can this different graphical formation be used as a frame to create a film/motion picture</li>
            </ul>

            <h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">The Core Algorithm (My Original Research)</h3>
            <p class="text-gray-700 mb-4">
                The technical paper that this project implements is my 2018 preprint, which provides the complete mathematical foundation for these operations.
            </p>
            <ul class="list-none mb-4 space-y-2">
                <li><strong class="text-gray-800">Paper:</strong> "Transformation of the pixels in Tupper's self-referential formula"</li>
                <li><strong class="text-gray-800">Author:</strong> Prathamesh Deshmukh (Me)</li>
                <li><strong class="text-gray-800">Publication Date:</strong> May 24, 2018</li>
            </ul>

            <p class="text-gray-700 mb-4">
                The core idea I explored in the paper is that any graphical formation plotted by Tupper's formula (in the $106 \times 17$ grid) can be transformed by applying arithmetic operations directly to the `k` constant.
            </p>
            <p class="text-gray-700 mb-4">This algorithm allows for precise transformations, including:</p>
            <ul class="list-disc list-inside space-y-3 mb-4 text-gray-700">
                <li><strong class="text-gray-800">Pixel Manipulation:</strong> Adding or removing any individual pixel `i` by adding or subtracting the value $17 \times 2^{i-1}$ from the `k` constant. (Equation C)</li>
                <li>
                    <strong class="text-gray-800">Spatial Translation (Moving):</strong>
                    <ul class="list-disc list-inside ml-6 mt-2 space-y-1">
                        <li><strong>Up/Down:</strong> Moving the entire image `n` pixels up or down by multiplying or dividing `k` by $2^n$.</li>
                        <li><strong>Left/Right:</strong> Moving the entire image `n` pixels left or right by multiplying or dividing `k` by $2^{n \times 17}$.</li>
                    </ul>
                </li>
                <li><strong class="text-gray-800">Animation (Framing):</strong> I also showed how these transformations can be applied sequentially to create a "film" or "motion picture" by treating each new `k` value as a frame. (Equation D)</li>
                <li><strong class="text-gray-800">Complex Transformations:</strong> The algorithm can also be used to apply different transformations to different pixels at the same time or to create diagonal movements.</li>
            </ul>
            
            <h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">How to Use This Demo</h3>
            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                <li>Select a mode: Animation, Interactive Tetris, or Manual Editor.</li>
                <li>The demo will load the relevant example from my paper.</li>
                <li>Use the contextual controls for each mode to transform the image.</li>
                <li>See the resulting `k` value and the updated image in real-time.</li>
            </ol>

            <h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">Citation & Publication History</h3>
            
            <div class="w-full my-6 rounded-lg overflow-hidden border border-gray-200 bg-gray-50" style="aspect-ratio: 568 / 351;">
                <iframe 
                    src="https://widgets.figshare.com/articles/6373046/embed?show_title=1" 
                    width="100%" 
                    height="100%" 
                    allowfullscreen 
                    frameborder="0"
                    class="w-full h-full">
                </iframe>
            </div>

            <h4 class="text-lg font-semibold mt-6 mb-2 text-gray-800">BibTeX Citation (Recommended)</h4>
            <pre class="language-bibtex rounded-lg"><code>@article{Deshmukh2018,
  author = "P Deshmukh",
  title = "{Transformation of the pixels in tupper's self-referential formula}",
  year = "2018",
  month = "6",
  url = "https://figshare.com/articles/preprint/Transformation_of_pixels_pdf/6373046",
  doi = "10.6084/m9.figshare.6373046.v2"
}</code></pre>

            <h4 class="text-lg font-semibold mt-6 mb-2 text-gray-800">Indexing &amp; Archives</h4>
            <div class="mt-4 space-y-3">
                <div class="bg-gray-50 p-3 rounded-md border">
                    <p class="font-semibold text-gray-800">Preferred Version (Figshare v2)</p>
                    <p class="text-sm text-gray-600">Deshmukh, P. (2018). <i>Transformation of the pixels in Tupper's self-referential formula</i>. Figshare. (DOI: 10.6084/m9.figshare.6373046)</p>
                    <p class="text-sm text-gray-600 mt-1"><strong>First Posted:</strong> June 08, 2018</p>
                    <a href="https://doi.org/10.6084/m9.figshare.6373046" target="_blank" rel="noopener noreferrer" class="text-blue-600 text-sm hover:underline break-all mt-1 block">https://doi.org/10.6084/m9.figshare.6373046</a>
                </div>

                <div class="bg-gray-50 p-3 rounded-md border">
                    <p class="font-semibold text-gray-800">Semantic Scholar Index</p>
                    <a href="https://www.semanticscholar.org/paper/Transformation-of-the-Pixels-in-Tupper's-Formula-Deshmukh/f7f02b429a5fcdc20a29410226c73eecaf992541" target="_blank" rel="noopener noreferrer" class="text-blue-600 text-sm hover:underline break-all">https://www.semanticscholar.org/paper/Transformation-of-the-Pixels-in-Tupper's-Formula-Deshmukh/f7f02b429a5fcdc20a29410226c73eecaf992541</a>
                </div>

                <div class="bg-gray-50 p-3 rounded-md border">
                    <p class="font-semibold text-gray-800">Internet Archive (Archive of v1)</p>
                    <a href="https://web.archive.org/web/20200220095114/https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/11711468/Transformation_of_pixels.pdf" target="_blank" rel="noopener noreferrer" class="text-blue-600 text-sm hover:underline break-all">httpsE://web.archive.org/web/20200220095114/https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/11711468/Transformation_of_pixels.pdf</a>
                </div>
            </div>

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const canvas = document.getElementById('tupperCanvas');
            const ctx = canvas.getContext('2d');
            const textarea = document.getElementById('k_value');

            // --- Modal Elements ---
            const btnReadMore = document.getElementById('btnReadMore');
            const aboutModal = document.getElementById('aboutModal');
            const btnCloseModal = document.getElementById('btnCloseModal');

            // --- Tab Buttons ---
            const btnAnimTab = document.getElementById('btnAnimTab');
            const btnTetrisTab = document.getElementById('btnTetrisTab');
            const btnManualTab = document.getElementById('btnManualTab');
            const tabs = [btnAnimTab, btnTetrisTab, btnManualTab];

            // --- Tab Panels ---
            const animationPanel = document.getElementById('animationPanel');
            const tetrisPanel = document.getElementById('tetrisPanel');
            const manualPanel = document.getElementById('manualPanel');
            const panels = [animationPanel, tetrisPanel, manualPanel];

            // --- Mode: Animation ---
            const btnStopAnim = document.getElementById('btnStopAnim');
            
            // --- Mode: Tetris ---
            const btnTetrisMoveLeft = document.getElementById('btnTetrisMoveLeft');
            const btnTetrisMoveRight = document.getElementById('btnTetrisMoveRight');
            const btnTetrisMoveDown = document.getElementById('btnTetrisMoveDown');

            // --- Mode: Static / Manual ---
            const btnLoadTupper = document.getElementById('btnLoadTupper');
            const btnLoadUFOCenter = document.getElementById('btnLoadUFOCenter'); 
            
            const btnMoveUp = document.getElementById('btnMoveUp');
            const btnMoveDown = document.getElementById('btnMoveDown');
            const btnMoveLeft = document.getElementById('btnMoveLeft');
            const btnMoveRight = document.getElementById('btnMoveRight');
            const btnMoveDiagUpRight = document.getElementById('btnMoveDiagUpRight');
            const manualAnimButtons = [btnMoveUp, btnMoveDown, btnMoveLeft, btnMoveRight, btnMoveDiagUpRight];
            
            // NEW: Manual Stop Button
            const btnStopManualAnim = document.getElementById('btnStopManualAnim');

            const inputPixelI = document.getElementById('pixel_i');
            const btnAddPixel = document.getElementById('btnAddPixel');
            const btnRemovePixel = document.getElementById('btnRemovePixel');
            
            // --- Constants from your paper ---
            const GRID_WIDTH = 106;
            const GRID_HEIGHT = 17;
            const H_BIGINT = BigInt(GRID_HEIGHT); // 17n
            const OFF_PIXEL_COLOR = '#f0f0f0';
            const ON_PIXEL_COLOR = '#000000';
            const ANIMATION_SPEED = 150; // ms for manual hold animation
            const LATCH_TIME = 1000; // 1 second hold to latch
            
            const TUPPER_K = 960939379918958884971672962127852754715004339660129306651505519271702802395266424689642842174350718121267153782770623355993237280874144307891325963941337723487857735749823926629715517173716995165232890538221612403238855866184013235585136048828693337902491454229288667081096184496091705183454067827731551705405381627380967602565625016981482083418783163849115590225610003652351370343874461848378737238198224849863465033159410054974700593138339226497249461751545728366702369745461014655997933798537483143786841806593422227898388722980000748404719n;
            const UFO_CENTER_K = 443352924415299750269935582831006891736908292088519263818614474851967119874782775886465719557549939463756309785941884807127269950858601139076519485343718480093603142421094905794300356122213456551693296459008206217500505569300664030340014779960166914732789553875507120518890769928117177323414356728568578317831865211788253557426913017856n;
            const UFO_TOP_LEFT_K = 3364095144409490406402517685013936223230541008369211472154153567830130294784n;
            
            // Tetris Piece Constants (Eg3.2, page 29)
            const KR_BIGINT = 1465173377163840840964195200776229452338097479160165100993321673778726174973516467105018733852068234022255298658975702245055915087238316041012593947856673785182723705258476099103213618090667396472262335593747367067648n;
            const KS_BIGINT = 42640449639783743164699946138133627753613984093735772109827003226441916669711823327553649089932323504047296961434448619137954569794030245783793507114789257497126216466424824493834668782237110139139800432640n;

            // --- State Variables ---
            let ufoAnimationInterval = null;
            let manualAnimationInterval = null; // For the 'hold' interval
            let manualAnimationTimer = null; // For the 'latch' timeout
            let isManualAnimationLatched = false; // Latch flag
            let currentTetrisPieceK = 0n; // Holds the transformed 'ks'

            /**
             * Core Drawing Function
             */
            function drawGrid(k) {
                if (typeof k !== 'bigint') {
                    console.error("drawGrid requires a BigInt");
                    return;
                }
                ctx.fillStyle = OFF_PIXEL_COLOR;
                ctx.fillRect(0, 0, GRID_WIDTH, GRID_HEIGHT);
                ctx.fillStyle = ON_PIXEL_COLOR;
                const k_div_17 = k / H_BIGINT;
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        const bit_position = BigInt(x * GRID_HEIGHT + y);
                        const bit = (k_div_17 >> bit_position) & 1n;
                        if (bit === 1n) {
                            ctx.fillRect(x, (GRID_HEIGHT - 1 - y), 1, 1);
                        }
                    }
                }
            }

            // --- Helper Functions ---
            function getCurrentK() {
                try {
                    const k_string = textarea.value.replace(/\s/g, '').replace('n', '');
                    if (k_string === "") return null;
                    return BigInt(k_string);
                } catch (e) {
                    alert("Invalid K-Value. It must be a valid (very large) integer.");
                    console.error(e);
                    return null;
                }
            }

            function updateK(newK) {
                textarea.value = newK.toString();
            }

            // --- Mode Switching Functions ---

            /** Stops the main UFO animation */
            function stopUFOAnimation() {
                if (ufoAnimationInterval) {
                    clearInterval(ufoAnimationInterval);
                    ufoAnimationInterval = null;
                }
            }

            /** Stops the manual hold-to-animate feature */
            function stopManualAnimation() {
                // If the animation has "latched", don't stop it on mouseup.
                // Only the "Stop Manual Animation" button can stop it.
                if (isManualAnimationLatched) {
                    return; 
                }
                
                // If we release *before* the latch, clear both the interval and the latch timer.
                if (manualAnimationInterval) {
                    clearInterval(manualAnimationInterval);
                    manualAnimationInterval = null;
                }
                if (manualAnimationTimer) {
                    clearTimeout(manualAnimationTimer);
                    manualAnimationTimer = null;
                }
            }

            /** Forcibly stops any manual animation and resets latch state */
            function forceStopManualAnimation() {
                if (manualAnimationInterval) {
                    clearInterval(manualAnimationInterval);
                    manualAnimationInterval = null;
                }
                if (manualAnimationTimer) {
                    clearTimeout(manualAnimationTimer);
                    manualAnimationTimer = null;
                }
                isManualAnimationLatched = false;
                btnStopManualAnim.classList.add('hidden'); // Hide the stop button
            }

            /** Stops ALL running animations */
            function stopAllAnimations() {
                stopUFOAnimation();
                forceStopManualAnimation();
            }

            /** Starts the UFO animation */
            function playUFOAnimation() {
                let currentK = UFO_TOP_LEFT_K; 
                updateK(currentK);
                drawGrid(currentK);
                
                ufoAnimationInterval = setInterval(() => {
                    // k' = k * 2^(1*17)
                    currentK = currentK * (2n ** H_BIGINT);
                    updateK(currentK);
                    drawGrid(currentK);
                }, 300); 
            }

            /** Updates the UI to show the correct panel for the selected tab */
            function showPanel(panelToShow, tabToActivate) {
                stopAllAnimations();
                
                panels.forEach(panel => panel.classList.add('hidden'));
                tabs.forEach(tab => tab.setAttribute('aria-selected', 'false'));
                
                panelToShow.classList.remove('hidden');
                tabToActivate.setAttribute('aria-selected', 'true');
            }

            /** Loads the Tetris demo */
            function loadTetrisDemo() {
                showPanel(tetrisPanel, btnTetrisTab);
                currentTetrisPieceK = KS_BIGINT; // Reset piece to original ks
                const totalK = KR_BIGINT + currentTetrisPieceK;
                updateK(totalK);
                drawGrid(totalK);
            }

            /** Loads the static/manual demo with a given K */
            function loadManualMode(k_value) {
                showPanel(manualPanel, btnManualTab);
                updateK(k_value);
                drawGrid(k_value);
            }

            /** Shows the animation panel and starts the animation */
            function showAnimationMode() {
                showPanel(animationPanel, btnAnimTab);
                playUFOAnimation();
            }
            
            // --- Modal Event Listeners ---
            btnReadMore.addEventListener('click', () => aboutModal.classList.remove('hidden'));
            btnCloseModal.addEventListener('click', () => aboutModal.classList.add('hidden'));
            aboutModal.addEventListener('click', (e) => {
                if (e.target === aboutModal) aboutModal.classList.add('hidden');
            });

            // --- Primary Mode Tab Button Listeners ---
            btnAnimTab.addEventListener('click', showAnimationMode);
            btnTetrisTab.addEventListener('click', loadTetrisDemo);
            btnManualTab.addEventListener('click', () => {
                // Load manual mode, keeping the current k if possible, otherwise default
                const currentK = getCurrentK();
                loadManualMode(currentK || UFO_CENTER_K);
            });
            btnStopAnim.addEventListener('click', () => {
                // Stop animation and switch to manual mode with the last K value
                const currentK = getCurrentK();
                loadManualMode(currentK);
            });


            // --- Static Load Button Listeners (inside Manual Panel) ---
            btnLoadTupper.addEventListener('click', () => loadManualMode(TUPPER_K));
            btnLoadUFOCenter.addEventListener('click', () => loadManualMode(UFO_CENTER_K));


            // --- Tetris Control Listeners (for k = kr + ks') ---
            btnTetrisMoveLeft.addEventListener('click', () => {
                // k' = kr + (ks / 2^(1*17))
                currentTetrisPieceK = currentTetrisPieceK / (2n ** H_BIGINT);
                const totalK = KR_BIGINT + currentTetrisPieceK;
                updateK(totalK);
                drawGrid(totalK);
            });
            btnTetrisMoveRight.addEventListener('click', () => {
                // k' = kr + (ks * 2^(1*17))
                currentTetrisPieceK = currentTetrisPieceK * (2n ** H_BIGINT);
                const totalK = KR_BIGINT + currentTetrisPieceK;
                updateK(totalK);
                drawGrid(totalK);
            });
            btnTetrisMoveDown.addEventListener('click', () => {
                // k' = kr + (ks / 2^1)
                currentTetrisPieceK = currentTetrisPieceK / 2n;
                const totalK = KR_BIGINT + currentTetrisPieceK;
                updateK(totalK);
                drawGrid(totalK);
            });

            // --- Manual Control Event Listeners (for k' = transform(k)) ---

            /**
             * NEW: Helper function to start a manual animation loop
             * @param {function(bigint): bigint} transformFunction - A function that takes a k and returns a new k
             */
            function startManualAnimation(transformFunction) {
                stopAllAnimations(); // Stop any other animation
                isManualAnimationLatched = false; // Reset latch
                
                let k = getCurrentK();
                if (!k) return;

                // Apply the first transform immediately on mousedown
                k = transformFunction(k);
                updateK(k);
                drawGrid(k);

                // Start the loop for continuous holding
                manualAnimationInterval = setInterval(() => {
                    k = transformFunction(k); // Note: 'k' is closed over, so it updates
                    updateK(k);
                    drawGrid(k);
                }, ANIMATION_SPEED);
                
                // Start the timer to "latch" the animation
                manualAnimationTimer = setTimeout(() => {
                    isManualAnimationLatched = true;
                    btnStopManualAnim.classList.remove('hidden'); // Show the stop button
                }, LATCH_TIME); // 1-second hold to latch
            }

            // Define the small transform functions
            const transformUp = (k) => k * 2n;
            const transformDown = (k) => k / 2n;
            const transformLeft = (k) => k / (2n ** H_BIGINT);
            const transformRight = (k) => k * (2n ** H_BIGINT);
            const transformDiag = (k) => (k * (2n ** H_BIGINT)) * 2n; // Up-Right

            // Wire up all manual animation buttons
            const stopEvents = ['mouseup', 'mouseleave', 'touchend'];
            
            btnMoveUp.addEventListener('mousedown', () => startManualAnimation(transformUp));
            btnMoveUp.addEventListener('touchstart', (e) => { e.preventDefault(); startManualAnimation(transformUp); });
            
            btnMoveDown.addEventListener('mousedown', () => startManualAnimation(transformDown));
            btnMoveDown.addEventListener('touchstart', (e) => { e.preventDefault(); startManualAnimation(transformDown); });
            
            btnMoveLeft.addEventListener('mousedown', () => startManualAnimation(transformLeft));
            btnMoveLeft.addEventListener('touchstart', (e) => { e.preventDefault(); startManualAnimation(transformLeft); });
            
            btnMoveRight.addEventListener('mousedown', () => startManualAnimation(transformRight));
            btnMoveRight.addEventListener('touchstart', (e) => { e.preventDefault(); startManualAnimation(transformRight); });
            
            btnMoveDiagUpRight.addEventListener('mousedown', () => startManualAnimation(transformDiag));
            btnMoveDiagUpRight.addEventListener('touchstart', (e) => { e.preventDefault(); startManualAnimation(transformDiag); });
            
            // Add stop listeners (for release *before* latch) to all of them
            manualAnimButtons.forEach(button => {
                stopEvents.forEach(event => {
                    button.addEventListener(event, stopManualAnimation);
                });
            });

            // NEW: Add listener for the "hard stop" button
            btnStopManualAnim.addEventListener('click', forceStopManualAnimation);


            // --- Manual Click Listeners (Pixel Ops) ---
            // These are still single-click
            btnAddPixel.addEventListener('click', () => {
                stopAllAnimations(); // Stop any hold-to-animate
                const k = getCurrentK();
                let i;
                try {
                    i = BigInt(inputPixelI.value);
                    if (i < 1n || i > 1802n) throw new Error("Index out of bounds");
                } catch(e) {
                    alert("Please enter a valid pixel index i (1-1802).");
                    return;
                }
                if (!k) return;
                const newK = k + (H_BIGINT * (2n ** (i - 1n)));
                updateK(newK);
                drawGrid(newK);
            });
            btnRemovePixel.addEventListener('click', () => {
                stopAllAnimations(); // Stop any hold-to-animate
                const k = getCurrentK();
                let i;
                try {
                    i = BigInt(inputPixelI.value);
                    if (i < 1n || i > 1802n) throw new Error("Index out of bounds");
                } catch(e) {
                    alert("Please enter a valid pixel index i (1-1802).");
                    return;
                }
                if (!k) return;
                const newK = k - (H_BIGINT * (2n ** (i - 1n)));
                updateK(newK);
                drawGrid(newK);
            });

            // --- Initial Load ---
            // Automatically select the Animation tab and play the UFO animation on page load
            showAnimationMode();
        });
    </script>

</body>
</html>